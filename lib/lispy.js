// Generated by LispyScript v0.3.6
require("./require");
var fs = require("fs"),
    ls = require("./ls"),
    repl = require("./repl"),
    isValidFlag = /-h\b|-r\b|-v\b|-b\b/,
    error = function(err) {
        console.error(err.message);
        return process.exit(1);
    };
var help_str = "\nUsage: lispy [-h] [-r] [-v] [-b] [<infile>] [<outfile>]\n\n       Also compile stdin to stdout\n       eg. $ echo '(console.log \"hello\")' | lispy\n\n       <no arguments>    Run REPL\n       -h                Show this help\n       -r                Compile and run\n       -v                Show Version\n       -b                Create browser-bundle.js in same folder.\n       <infile>          Input file to compile\n       <outfile>         Output JS file. If not given\n                         <outfile> will be <infile> with .js extension\n";
(function(___monad) {
    var mBind = ___monad.mBind,
        mResult = ___monad.mResult,
        mZero = ___monad.mZero,
        mPlus = ___monad.mPlus;
    var ____mResult = function(___arg) {
        return (((typeof(___arg) === "undefined") && (!(typeof(mZero) === "undefined"))) ?
            mZero :
            mResult(___arg));
    };
    return mBind(process.argv.slice(2),function(args) {
        return mBind(args.shift(),function(arg1) {
            return mBind(((typeof(arg1) === "undefined") ?
                (function() {
                    var input = process.stdin;
                    var output = process.stdout;
                    input.resume();
                    input.setEncoding("utf8");
                    var source = "";
                    input.on("data",function(chunck) {
                        source = (source + chunck.toString());
                    });
                    input.on("end",function() {
                        return (function() {
                        try {
                            return output.write(ls._compile(source,process.cwd));

                        } catch (e) {
                        return (error)(e);
                        }
                        })();
                    });
                    input.on("error",error);
                    output.on("error",error);
                    setTimeout(function() {
                        return ((input.bytesRead === 0) ?
                            (function() {
                                input.removeAllListeners("data");
                                return repl.runrepl();
                            })() :
                            undefined);
                    },20);
                    return null;
                })() :
                undefined),function(noargs) {
                return mBind((("-" === arg1[0]) ?
                    (function() {
                        var flag = arg1;
                        arg1 = args.shift();
                        return (isValidFlag.test(flag) ?
                            flag :
                            error(new Error(("Error: Invalid flag " + flag))));
                    })() :
                    undefined),function(flag) {
                    return mBind((("-h" === flag) ?
                        (function() {
                            console.log(help_str);
                            return null;
                        })() :
                        (("-v" === flag) ?
                            (function() {
                                console.log(("Version " + ls.version));
                                return null;
                            })() :
                            (("-b" === flag) ?
                                (function() {
                                    var bundle = require.resolve("lispyscript/lib/browser-bundle.js");
                                    (fs.createReadStream(bundle)).pipe(fs.createWriteStream("browser-bundle.js"));
                                    return null;
                                })() :
                                (("-r" === flag) ?
                                    true :
                                    undefined)))),function(run) {
                        return mBind((arg1 ?
                            arg1 :
                            error(new Error("Error: No Input file given"))),function(infile) {
                            return mBind((function() {
                                var outfile = args.shift();
                                ((!outfile) ?
                                    (function() {
                                        return (function() {
                                            outfile = infile.replace(/\.ls$/,".js");
                                            return ((outfile === infile) ?
                                                error(new Error("Error: Input file must have extension '.ls'")) :
                                                undefined);
                                        })();
                                    })() :
                                    undefined);
                                return outfile;
                            })(),function(outfile) {
                                return mBind((function() {
                                try {
                                    fs.writeFileSync(outfile,ls._compile(fs.readFileSync(infile,"utf8"),infile),"utf8");
                                    return (run ?
                                        run :
                                        null);

                                } catch (e) {
                                return (function(err) {
                                    error(err);
                                    return null;
                                })(e);
                                }
                                })(),function(js) {
                                    return (function() {
                                        return ____mResult((require("child_process")).spawn("node",[outfile],{stdio: "inherit"}));
                                    })();
                                });
                            });
                        });
                    });
                });
            });
        });
    });
})({
    mBind: function(mv,mf) {
        return ((mv === null) ?
            null :
            mf(mv));
    },
    mResult: function(v) {
        return v;
    },
    mZero: null
});
